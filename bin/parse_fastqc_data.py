#!/usr/bin/env python3

import json
import os
import sys
import logging
logging.basicConfig(format='%(levelname)s:%(message)s', level=logging.INFO)


def parse_fastq_data(fp_in, fp_out):
    """Parse the raw data generated by FastQC to provide JSON structure."""

    # Keep all output in a single dict
    output = dict()

    # The FastQC data is broken into modules, each of which has a header
    module_name = None
    header = None

    # Open the input file
    with open(fp_in, 'r') as handle:

        # Iterate over each line
        for line in handle:

            # The end of each module is marked by >>END_MODULE
            if line.startswith(">>END_MODULE"):
                
                # Clear the module name and header
                module_name = None
                header = None

            # The beginning of each module is marked with '>>'
            elif line.startswith(">>"):

                # Parse the module name and status from the line
                module_name, module_status = line[2:].rstrip("\n\r").split("\t")

                # Record the module name and status in the output
                output[module_name] = dict(
                    status=module_status,
                    data=list()
                )

            # After each module starts, there should be a header line
            elif line.startswith("#"):

                # Parse the header fields from the line
                header = line[1:].rstrip('\n\r').split("\t")

            # Otherwise, the line should contain data
            else:

                # Parse the data from the line
                fields = line.rstrip('\n\r').split("\t")

                # If we are in this block, there should be a header list defined
                assert header is not None, line

                # The number of fields should be the same in the header and this row
                assert len(header) == len(fields)

                # Add the data for this row to the output
                output[module_name]['data'].append(dict(zip(header, fields)))

    # Open the output file
    logging.info(f"Writing out to {fp_out}")
    with open(fp_out, 'w') as handle:

        # Write out in JSON format
        json.dump(output, handle, indent=4)

    logging.info("Done")


if __name__ == "__main__":

    # Get the file paths from the user
    logging.info("Parsing arguments")
    assert len(sys.argv) == 3

    # Input file
    fp_in = sys.argv[1]
    logging.info(f"User provided input file: {fp_in}")
    assert os.path.exists(fp_in)

    # Output file
    fp_out = sys.argv[2]
    logging.info(f"User provided output file: {fp_out}")
    assert fp_out.endswith(".json"), "Output file must have the extension '.json'"
    assert fp_in != fp_out

    parse_fastq_data(fp_in, fp_out)
